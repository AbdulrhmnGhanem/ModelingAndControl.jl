function [G, Y, U, CYU] = NL_Anal_FRF(Yall, Uall, Rall);%%		function [G, Y, U, CYU] = NL_Anal_FRF(Yall, Uall, Rall);%%       %           Nonlinear analysis of FRF or input/output measurements at F frequencies%           made with different M phase realisations of random phase multisines with the%           same rms value and amplitude spectrum. P consecutive periods are measured%%       Usage%           1. The difference between varG and varGn is a measure of%              the level of the stochastic nonlinear distortions on G%           2. The NL distortion level on one realisation random phase%              multisine measurement varGs = M * (varG - varGn)%%       Examples%           1. [G] = NL_Anal_FRF(Gall)  where Gall is an M x P x F matrix of FRF's%           2. [G] = NL_Anal_FRF(Yall, Uall)  where Yall, Uall are  M x P x F matrices of output, input spectra%           3. [G, Y, U, CYU] = NL_Anal_FRF(Yall, Uall, Rall)  where Yall, Uall are  M x P x F matrices of output, input spectra%                                                         and Rall is M x P x F or M x F matrix of the reference signals%%	OUTPUT PARAMETERS%%	    G		:	struct('mean', 'stdNL', 'stdn', 'stds')%                   G.mean  :   mean value of FRF estimate over the M x P FRF measurements%                   G.stdNL :   total standard deviation mean FRF (contribution noise + NL distortion)%                   G.stdn  :   noise standard deviation mean FRF%                   G.stds  :   standard deviation stochastic NL distortions w.r.t. one multisine experiment%                               = order of magnitude of NL bias errors = the difference between the best linear approximation G%                               and the true underlying linear system)%%       Y       :   mean value projected output Yall./Rall over all periods and realisations%       U       :   mean value projected input Uall./Rall over all periods and realisations%       CYU     :   covariance matrix of [Y; U], CYU = E{[Y; U] * [Y; U]^H}, size 2 x 2 x F%%	INPUT PARAMETERS%%	    Yall	:	M x P x F FRF or output spectrum measurements, where F is the number of frequencies,%				    P the number of consecutive periods of one realisation of the random multisine excitation,%                   and M is the number of independent realisations of the random phase multisine with%                       1. the same rms value%                       2. the same amplitude spectrum%                   If only one argument is passed then Yall = Gall = FRF measurements%       Uall    :   Optional argument, M x P x F input spectrum measurements%       Rall    :   Optional argument, M x P x F or M x F matrix of the spectra of the M reference signals (signal stored in the waveform generator)%% Rik Pintelon, November 2004% version June 2006%%%%%%%%%%%%%%%%%%%% initialisation %%%%%%%%%%%%%%%%%%%[M, P, F] = size(Yall);G = struct('mean', [], 'stdn', [], 'stdNL', [], 'stds', []);%%%%%%%%%%%%%%%%%%%%%%%%%% FRF measurements only %%%%%%%%%%%%%%%%%%%%%%%%%%if (nargin == 1)    	G = squeeze(mean(mean(Yall, 2), 1));	if M > 1		G.stdNL = squeeze(std(mean(Yall, 2), 0, 1))/sqrt(M);	end;	if P > 1		G.stdn = (squeeze(mean(std(Yall, 0, 2).^2, 1))/(M*P)).^0.5;	end	if (M > 1) & (P > 1)        G.stds = (M * abs(G.stdNL.^2 - G.stdn.^2)).^05;	end    end % if nargin = 1%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% input/output measurements %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if (nargin == 2) | (nargin == 3)        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % If the reference signal is available then project      %    % input and output on reference signal.                  %    % It allows to average the spectra over the realisations %    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    if nargin == 3        % M x F matrix of reference spectra        if length(size(Rall)) == 2            dummy = zeros(M, P, F);            dummy(1, :, :) = Rall;            Rall = dummy;        end % if dim(Rall) = 2        Uall = Uall ./ Rall;        Yall = Yall ./ Rall;    end % if nargin = 3        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % mean and variance over P periods %    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % averaging spectra over periods before FRF calculation    Uallm = mean(Uall, 2);                                              % mean over consecutive periods	Yallm = mean(Yall, 2);                                              % mean over consecutive periods    if P > 1		resUall = Uall - repmat(Uallm, [1, P, 1]);		resYall = Yall - repmat(Yallm, [1, P, 1]);		varUallm = squeeze((sum(abs(resUall.^2), 2)/(P-1)/P));          % var mean value over P periods		varYallm = squeeze((sum(abs(resYall.^2), 2)/(P-1)/P));          % var mean value over P periods		varYUallm = squeeze(sum(resYall.*conj(resUall), 2)/(P-1)/P);        % covariance mean values over P periods    end % if P > 1	Uallm = squeeze(Uallm);	Yallm = squeeze(Yallm);	if M == 1        Uallm = Uallm.';        Yallm = Yallm.';        if P > 1             varUallm = varUallm.';            varYallm = varYallm.';            varYUallm = varYUallm.';        end % if P > 1	end % if M == 1    Gallm = Yallm ./ Uallm;    if P > 1        % noise variance        varGallm = abs(Gallm.^2) .* (varYallm./abs(Yallm.^2) + varUallm./abs(Uallm.^2) ...                                     - 2*real(varYUallm./(Yallm .* conj(Uallm))));        G.stdn = (mean(varGallm, 1) / M).^0.5;                                  % var mean value over M realisations    end % if P > 1                               %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % Mean and variance over M realisations in the absence of a reference signal          %    % Averaging spectra over realisations is impossible because they are not synchronized %    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        if nargin == 2                G.mean = mean(Gallm, 1);		if M > 1			G.stdNL = std(Gallm, 0, 1) / sqrt(M);         % variance mean value		end;		if (M > 1) & (P > 1)            G.stds = (M * abs(G.stdNL.^2 - G.stdn.^2)).^0.5;		end            end % if nargin = 2                             %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % Mean and variance over M realisations in the presence of a reference signal %    % Due to the projection on the reference signal averaging of the spectra over %    % different realisations is possible                                          %    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        if nargin == 3                % mean value over realisations        Y = mean(Yallm, 1);        U = mean(Uallm, 1);        G.mean = Y./U;                if M > 1            CYU = zeros(2, 2, F);			resU = Uallm - repmat(U, [M, 1]);			resY = Yallm - repmat(Y, [M, 1]);			varU = (sum(abs(resU.^2), 1)/(M-1)/M);                  % var mean value over M realisations			varY = (sum(abs(resY.^2), 1)/(M-1)/M);                  % var mean value over M realisations			varYU = sum(resY.*conj(resU), 1)/(M-1)/M;               % covariance mean values over M realisations                        % covariance matrix [Y; U]            CYU(1, 1, :) = varY;            CYU(2, 2, :) = varU;            CYU(1, 2, :) = varYU;            CYU(2, 1, :) = conj(varYU);                        % total variance mean FRF                    else            CYU = [];        end % if M > 1                    end % if nargin = 3    end % if nargin = 2 or nargin = 3