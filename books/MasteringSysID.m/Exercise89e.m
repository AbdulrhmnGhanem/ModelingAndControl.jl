% Chapter 6 Exercise 89.e% Bias on the estimated odd and even distortion levels%% Copyright: % Johan Schoukens, Rik Pintelon, and Yves Rolain % Vrije Universiteit Brussels, Pleinlaan 2, 1050 Brussels, Belgium%% 8 December 2010%  choice of the type of multisine (full, odd, random grid)%       at lines: 52-56%  lin or log resolution: at line 42-47%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                                           %% % Analysis of the bias of the fast method for analysing the nonlineair      %%% distortions in case the detection lines of the input contain signal       %%% energy                                                                    %%%                                                                           %%% Illustrated on a continuous-time Wiener-Hammerstein system consisting     %%% of the cascade of                                                         %%%                                                                           %%%   1. a second order system:           G1(s) = 1/(1 + s/(Q*w0) + s^2/w0^2) %%%   2. a static nonlinear function:     x + alpha*x^2 + beta*x^3            %%%   3. a first order system:            G2(s) = 1/(1 + Tau*s)               %%%                                                                           %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%clear allclose all;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition of the Wiener-Hammerstein system %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% second order system G1(s)f0 = 1000;								% resonance frequency at 1 kHzQ = 10;									% quality factor% first order system G2(s)Tau = 1/(2*pi*300);						% 3 dB point at 300 Hz% sampling frequency: 12.5 times oversampling to avoid alias problemsfs = 5e4;								% 50 kHz% static nonlinearityalpha = 0.01;beta3 = 0.005;beta3 = 0.0005;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition actuator characteristic %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2th order Chebyshev filter with a passband ripple of 6 dB and% a cutoff frequency of 2000 Hz[bcheb, acheb] = cheby1(4, 6, 2*pi*2000, 's');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition random phase multisine experiment % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% random phase multisine parametersrms = 1;                                % rms value multisinefmin = 4;                               % minimal frequencyfmax = 2000;							% maximal frequency 2 kHzfres = 4;                               % frequency resolution multisineTypeMultisine = 'odd';                  % odd random phase random harmonic grid multisineSpacing = 'lin';                        % linear frequency spacingNblock = 2;DefFreq.fmin = fmin;DefFreq.fmax = fmax;DefFreq.fs = fs;DefFreq.fres = fres;[ExcitedHarm, N, NewDefFreq] = HarmMultisine(DefFreq, Nblock, Spacing, TypeMultisine);MeasHarm = [1:1:round(fmax/(fs/N))];% detection lines in MeasHarmDistortEvenOnly = 1;                    % distort only the even input detection lines% DistortEvenOnly = 0;                    % distort the even and odd input detection linesDetectLines = MeasHarm;switch DistortEvenOnly    case 0        HH = length(ExcitedHarm);        DeleteLines = zeros(size(ExcitedHarm));        for ii = 1:HH            DeleteLines(ii) = find(MeasHarm == ExcitedHarm(ii));        end % ii;        DetectLines(DeleteLines) = [];    case 1        DetectLines(1:2:end) = []; end % switch              ScaleDetect = 10;                     % scaling w.r.t. the excited lines% parameters experimentP = 2;                                  % number of consecutive periods multisineM = 1000;                               % number of independent repeated experimentsFall = length(MeasHarm);                % number of measured frequenciesUall = zeros(M, P, Fall);               % all input spectra at the measured frequenciesYall = zeros(M, P, Fall);               % all output spectra at the measured frequenciesUdall = zeros(M, P, Fall);              % all input spectra at the measured frequenciesYdall = zeros(M, P, Fall);              % all output spectra at the measured frequencies%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Disturbing input/output noise %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%stdu = 0.01/100;stdy = 0.01/100;                   % output noise standard deviation%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FRF using multisine excitation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculation linear transfer functions from DC to Nyquist% at the resolution of the multisine periodfreqN = [0:1:N/2]*fs/N;sN =  2*pi*freqN*sqrt(-1);Gfirst = 1./polyval([1/(2*pi*f0)^2 1/(Q*2*pi*f0) 1], sN);Gsecond = 1./polyval([Tau 1], sN);Gactuator = polyval(bcheb, sN) ./ polyval(acheb, sN);for mm = 1:M		home	mm           % generation one period random phase multisine    r = rms*CalcMultisine(ExcitedHarm, N);    r = r.';    stdr = std(r);	    % calculate the noiseless output u0(t) of the actuator    R = fft(r);    U0 = zeros(1,N);    U0(1:N/2+1) = Gactuator.*R(1:N/2+1);    % take 2 times real part since the complex conjugate was not added in U0    u0 = 2*real(ifft(U0));        % response to distorted reference signal    Rd = zeros(1,N);    Rd(1:N/2+1) = R(1:N/2+1);    Rd(DetectLines+1) = (abs(Rd(ExcitedHarm(1)+1))/ScaleDetect)*exp(-sqrt(-1)*2*pi*rand(size(DetectLines)));    rd = 2*real(ifft(Rd));    rd = rd/std(rd)*stdr;    Rd = fft(rd);    Ud = zeros(1,N);    Ud(1:N/2+1) = Gactuator.*Rd(1:N/2+1);    % take 2 times real part since the complex conjugate was not added in U0    ud = 2*real(ifft(Ud));     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	% calculate the noiseless output y0(t) of the Wiener-Hammerstein system %    % of the spectrally pure input                                          %     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        % signal after first linear dynamic system: X = Gfirst*U0        X = zeros(1,N);        X(1:N/2+1) = Gfirst.*U0(1:N/2+1);        % take 2 times real part since complex conjugate was not added in X        x = 2*real(ifft(X));        % signal after static nonlinearity: z = scale*fNL(x/scale)        z = x + alpha*x.^2 + beta3*x.^3; %       z = x + alpha*x.^2 + beta5*x.^5;        % signal after second linear dynamic system: Y = Gsecond*Z        Z = fft(z);        Y0 = zeros(1,N);        Y0(1:N/2+1) = Gsecond.*Z(1:N/2+1);        % take 2 times real part since complex conjugate was not added in Y        y0 = 2*real(ifft(Y0));		% calculate scaled input output spectra at the excited frequencies	U0 = fft(u0);	U0 = U0(MeasHarm+1)/sqrt(N);                     % select the excited frequencies	Y0 = fft(y0);	Y0 = Y0(MeasHarm+1)/sqrt(N);                     % select the excited frequencies        Uall(mm, :, :) = repmat(U0, [P, 1]);    Yall(mm, :, :) = repmat(Y0, [P, 1]);         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	% calculate the noiseless output y0(t) of the Wiener-Hammerstein system %    % of the distorted input                                                %     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        % signal after first linear dynamic system: X = Gfirst*U0        X = zeros(1,N);        X(1:N/2+1) = Gfirst.*Ud(1:N/2+1);        % take 2 times real part since complex conjugate was not added in X        x = 2*real(ifft(X));        % signal after static nonlinearity: z = scale*fNL(x/scale)        z = x + alpha*x.^2 + beta3*x.^3;%         z = x + alpha*x.^2 + beta5*x.^5;        % signal after second linear dynamic system: Y = Gsecond*Z        Z = fft(z);        Yd = zeros(1,N);        Yd(1:N/2+1) = Gsecond.*Z(1:N/2+1);        % take 2 times real part since complex conjugate was not added in Y        yd = 2*real(ifft(Yd));		% calculate scaled input output spectra at the excited frequencies	Ud = fft(ud);	Ud = Ud(MeasHarm+1)/sqrt(N);                     % select the excited frequencies	Yd = fft(yd);	Yd = Yd(MeasHarm+1)/sqrt(N);                     % select the excited frequencies                Udall(mm, :, :) = repmat(Ud, [P, 1]);    Ydall(mm, :, :) = repmat(Yd, [P, 1]);	    end% add noise to the input/output spectraUall = Uall + stdu*(randn(size(Uall)) + sqrt(-1)*randn(size(Uall)))/sqrt(2);Yall = Yall + stdy*(randn(size(Yall)) + sqrt(-1)*randn(size(Yall)))/sqrt(2);% add noise to the input/output spectraUdall = Udall + stdu*(randn(size(Udall)) + sqrt(-1)*randn(size(Udall)))/sqrt(2);Ydall = Ydall + stdy*(randn(size(Ydall)) + sqrt(-1)*randn(size(Ydall)))/sqrt(2);% NL analysis on IO spectra[Y, Yc, U, G, freq] = Fast_NL_Anal(Yall, Uall, ExcitedHarm, MeasHarm, fs, N);% NL analysis on IO spectra[Yd, Ydc, Ud, Gd, freq] = Fast_NL_Anal(Ydall, Udall, ExcitedHarm, MeasHarm, fs, N);% plot resultsRealNum = 5;            % number of realisation to be plottedFigNum = 1;             % number of first figurePlot_Fast_NL_Anal(Y, Yc, U, G, freq, Spacing, RealNum, FigNum);% plot resultsRealNum = 5;            % number of realisation to be plottedFigNum = 7;             % number of first figurePlot_Fast_NL_Anal(Yd, Ydc, Ud, Gd, freq, Spacing, RealNum, FigNum);% rms average corrected output spectrum (spectrally pure input)Ycrms = Yc;Ycrms.mean.E = mean(abs(Ycrms.mean.E.^2),1).^0.5;Ycrms.mean.NE.even = mean(abs(Ycrms.mean.NE.even.^2),1).^0.5;Ycrms.mean.NE.odd = mean(abs(Ycrms.mean.NE.odd.^2),1).^0.5;Ycrms.std.E = mean(abs(Ycrms.std.E.^2),1).^0.5;Ycrms.std.NE.even = mean(abs(Ycrms.std.NE.even.^2),1).^0.5;Ycrms.std.NE.odd = mean(abs(Ycrms.std.NE.odd.^2),1).^0.5;% rms average corrected output spectrum (distorted input)Ydcrms = Ydc;Ydcrms.mean.E = mean(abs(Ydcrms.mean.E.^2),1).^0.5;Ydcrms.mean.NE.even = mean(abs(Ydcrms.mean.NE.even.^2),1).^0.5;Ydcrms.mean.NE.odd = mean(abs(Ydcrms.mean.NE.odd.^2),1).^0.5;Ydcrms.std.E = mean(abs(Ydcrms.std.E.^2),1).^0.5;Ydcrms.std.NE.even = mean(abs(Ydcrms.std.NE.even.^2),1).^0.5;Ydcrms.std.NE.odd = mean(abs(Ydcrms.std.NE.odd.^2),1).^0.5;figure(13)subplot(211)plot(freq.E, db(Ycrms.mean.E), 'k+', freq.E, db(Ycrms.std.E), 'k', ...     freq.NE.odd.inband, db(Ycrms.mean.NE.odd), 'ro', freq.NE.odd.inband, db(Ycrms.std.NE.odd), 'r', ...     freq.NE.even.inband, db(Ycrms.mean.NE.even), 'b*', freq.NE.even.inband, db(Ycrms.std.NE.even), 'b');title('spectrally pure input')subplot(212)plot(freq.E, db(Ydcrms.mean.E), 'k+', freq.E, db(Ydcrms.std.E), 'k', ...     freq.NE.odd.inband, db(Ydcrms.mean.NE.odd), 'ro', freq.NE.odd.inband, db(Ydcrms.std.NE.odd), 'r', ...     freq.NE.even.inband, db(Ydcrms.mean.NE.even), 'b*', freq.NE.even.inband, db(Ydcrms.std.NE.even), 'b');title('distorted input') %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% comparison NL distortion estimate %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%figure(14)plot(freq.NE.odd.inband, db(Ycrms.mean.NE.odd), 'ro', ...     freq.NE.even.inband, db(Ycrms.mean.NE.even), 'b*', ...     freq.NE.odd.inband, db(Ydcrms.mean.NE.odd), 'ro', ...     freq.NE.even.inband, db(Ydcrms.mean.NE.even), 'b*');