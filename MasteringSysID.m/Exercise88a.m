function Exercise88a% Chapter 6 Exercise 88.a% Robust method for noisy FRF measurements%% Copyright: % Johan Schoukens, Rik Pintelon, and Yves Rolain % Vrije Universiteit Brussels, Pleinlaan 2, 1050 Brussels, Belgium%% 7 December 2010%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Robust method for measuring the BLA, its variance, the noise variance     %%% and the variance of the stochastic nonlinear distortions for known input, %%% noisy output measurements                                                 %%%                                                                           %%% Illustrated on a continuous-time Wiener-Hammerstein system consisting     %%% of the cascade of                                                         %%%                                                                           %%%   1. a second order system:           G1(s) = 1/(1 + s/(Q*w0) + s^2/w0^2) %%%   2. a static nonlinear function:     5*tanh(x/5)                         %%%   3. a first order system:            G2(s) = 1/(1 + Tau*s)               %%%                                                                           %% % for the following excitation signals                                      %% %                                                                           %% %   1. random phase multisines                                              %%%   2. Gaussian noise                                                       %%%                                                                           %% % with the same bandwidth and rms value.                                    %% %                                                                           %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%close all;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition of the Wiener-Hammerstein system %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% second order system G1(s)f0 = 1000;								% resonance frequency at 1 kHzQ = 10;									% quality factor% first order system G2(s)Tau = 1/(2*pi*300);						% 3 dB point at 300 Hz% sampling frequency: 12.5 times oversampling to avoid alias problemsfs = 5e4;								% 50 kHz%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition actuator characteristic %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2th order Chebyshev filter with a passband ripple of 6 dB and% a cutoff frequency of 2000 Hz[bcheb, acheb] = cheby1(4, 6, 2*pi*2000, 's');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition random phase multisine experiment % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% random phase multisine parametersfmax = 2000;							% maximal frequency 2 kHzF = 500;								% number of frequencies (0, fmax]N = fs/fmax*F;							% number of points per periodAmpl = ones(1,F);						% amplitudes random phase multisinefreq = [1:1:F]*fs/N;                    % excited frequencies multisinerms = 1;                                % rms value multisine% parameters experimentP = 2;                                  % number of consecutive periods multisineM = 60;                                  % number of independent repeated experimentsGmultiAll = zeros(M, P, F);             % FRF measured with multisine%%%%%%%%%%%%%%%%%%%%% Disturbing noise %%%%%%%%%%%%%%%%%%%%%stdy = sqrt(N/2/F)/50;                   % output noise standard deviation%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FRF using multisine excitation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculation linear transfer functions from DC to Nyquist% at the resolution of the multisine periodfreqN = [0:1:N/2]*fs/N;sN =  2*pi*freqN*sqrt(-1);Gfirst = 1./polyval([1/(2*pi*f0)^2 1/(Q*2*pi*f0) 1],sN);Gsecond = 1./polyval([Tau 1],sN);Gactuator = polyval(bcheb, sN) ./ polyval(acheb, sN);for mm = 1:M		home	fprintf('experiment %e \n',mm);    	% calculate the reference signal r(t)	Phasor = exp(sqrt(-1)*2*pi*rand(1,F));		% uniformly distributed phases [0,2¹)	R = [0 Ampl.*Phasor zeros(1,N-F-1)];		% input spectrum to calculate r(t)	r = 2*real(ifft(R));						% take 2 times real part since complex conjugate was not added in R	r = rms*r/std(r);                           % input must have normalised input power of 1	    % calculate the noiseless output u0(t) of the actuator    R = fft(r);    U = zeros(1,N);    U(1:N/2+1) = Gactuator.*R(1:N/2+1);    % take 2 times real part since the complex conjugate was not added in U0    u = 2*real(ifft(U)); 	% calculate the noiseless output y0(t) of the Wiener-Hammerstein system		[y0, z] = WH(u, Gfirst, 'tanh', 5, Gsecond);		% calculate scaled input output spectra at the excited frequencies	U = fft(u);	U = U(2:F+1)/sqrt(N);                       % select the excited frequencies	Y0 = fft(y0);	Y0 = Y0(2:F+1)/sqrt(N);                     % select the excited frequencies		for pp = 1:P		% add measurement noise on output spectra		Y = Y0 + stdy*(randn(size(Y0)) + sqrt(-1)*randn(size(Y0)))/sqrt(2);		GmultiAll(mm, pp, :) = Y./U;	end % pp	end% calculate the mean FRF, its sample variance, the noise variance, and the% variance of the stochastic nonlinear contributions[Gmulti] = BLA_per(GmultiAll);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FRF using Gaussian noise excitation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Nnoise = N*P*M;                     % number of samples for the Gaussian noise excitation such that                                    % the total measurement time is the same as for the random phase multisine                                    % calculation linear transfer functions from DC to Nyquist at the resolution of% the block length N*P which is chosen such that the averaging of the nonlinear % distortions is the same as for the random phase multisinefreqN = [0:1:Nnoise/2]*fs/Nnoise;sN =  2*pi*freqN*sqrt(-1);Gfirst = 1./polyval([1/(2*pi*f0)^2 1/(Q*2*pi*f0) 1], sN);Gsecond = 1./polyval([Tau 1], sN);Gactuator = polyval(bcheb, sN) ./ polyval(acheb, sN);% Gaussian noise reference signalr = randn(1, Nnoise);R = fft(r);R(1+P*M*F:end) = 0;                         % impose the bandwidth of 2 kHzr = 2*real(ifft(R));r = rms*r/std(r);R = fft(r);% output of the actuatorU = zeros(1,Nnoise);U(1:Nnoise/2+1) = Gactuator.*R(1:Nnoise/2+1);% take 2 times real part since the complex conjugate was not added in Uu = 2*real(ifft(U));% calculate the noiseless output of the Wiener-Hammerstein system[y0, z] = WH(u, Gfirst, 'tanh', 5, Gsecond);% add noise with a bandwidth of 2 kHz to the outputynoise = randn(1,Nnoise);Ynoise = fft(ynoise)/sqrt(Nnoise);Ynoise(1+P*M*F:end) = 0;Ynoise = Ynoise*stdy;ynoise = 2*real(ifft(Ynoise)*sqrt(Nnoise));y = y0 + ynoise;% calculate the FRF and its variance[Gnoise, varGnoise, freqnoise] = BLA_arb(y, u, N*P, fs);% select the excited frequency bandSelect = find(freqnoise <= 2000);Gnoise = Gnoise(Select);varGnoise = varGnoise(Select);freqnoise = freqnoise(Select);%%%%%%%%%%%%% Graphics %%%%%%%%%%%%%figure(1)set(gcf, 'Position',[300 200 600 800])      % larger window for plottingTheAxis = [0 2000 -60 20];subplot(311)plot(freq, db(Gmulti.mean), 'k', freq, db(Gmulti.stdNL), 'r', freq, db(Gmulti.stdn), 'g', freq, db(Gmulti.stds), 'b')axis(TheAxis);xlabel('Frequency (Hz)')ylabel('Amplitude (db)')title('Multisine: BLA (black), total variance (red), noise variance (green), stochastic NL distortion (blue)')subplot(312)plot(freqnoise, db(Gnoise), 'k', freqnoise, db(varGnoise)/2, 'r')axis(TheAxis);xlabel('Frequency (Hz)')ylabel('Amplitude (db)')title('Gaussian noise: BLA (black), total variance (red)')subplot(313)plot(freqnoise, db(varGnoise)/2, 'r',  freq, db(Gmulti.stdNL), 'r:')axis(TheAxis);xlabel('Frequency (Hz)')ylabel('Amplitude (db)')title('Total variance: solid (Gaussian noise), dashed (multisine)')zoom on;shgfunction [G, Y, U, CYU] = BLA_per(Yall, Uall, Rall);%%		function [G, Y, U, CYU] = BLA_per(Yall, Uall, Rall);%%       %           Nonlinear analysis of FRF or input/output measurements at F frequencies%           made with different M phase realisations of random phase multisines with the%           same rms value and amplitude spectrum. P consecutive periods are measured%%           Yall(m,p,k) = Y0[m,p](k) + NY[m, p](k) + YS[m](k)%           Uall(m,p,k) = U0[m,p](k) + NU[m, p](k)%           Rall(m,p,k) = R[m](k) = |R(k)| exp(sqrt(-1)*angle(R[m](k)))%%       Examples%           1. [G] = BLA_per(Gall)                          where Gall is an M x P x F matrix of FRF's%           2. [G] = BLA_perYall, Uall)                     where Yall, Uall are  M x P x F matrices of output, input spectra%           3. [G, Y, U, CYU] = BLA_per(Yall, Uall, Rall)	where Yall, Uall are  M x P x F matrices of output, input spectra%                                                         	and Rall is M x P x F or M x F matrix of the spectra of the reference signals%%	OUTPUT PARAMETERS%%	    G		:	struct('mean', 'stdNL', 'stdn', 'stds')%                   G.mean  :   mean value of FRF estimate over the M x P FRF measurements%                   G.stdNL :   total standard deviation mean FRF (contribution noise + NL distortion)%                   G.stdn  :   noise standard deviation mean FRF%                   G.stds  :   standard deviation stochastic NL distortions w.r.t. one multisine experiment%                               = order of magnitude of NL bias errors = the difference between the best linear approximation G%                                 and the true underlying linear system%%       Y       :   struct('mean', 'abs', 'stdn', 'stdNL', 'stds')%                   Y.mean	:   if Rall is available then%                                    Y.mean is the mean value of the projected output Yall./Rall%                                    over all periods and realisations%                               else%                                   Y.mean is empty except if M = 1 then Y.mean is the mean value of the%                                   output over all periods%                   Y.abs	:   if Rall is available then%                                   Y.abs = abs(Y.mean) %                               else%                                   rms value |Y(k)| over different realisations compensated for the noise variance %                   Y.stdNL :   total variance Y.mean (as complex number) %                   Y.stdn  :   noise variance Y.mean (as complex number)%                   Y.stds  :   output stochastic nonlinear distortions w.r.t. one multisine realisation %%       U       :   struct('mean', 'abs', 'stdn', 'stdNL', 'stds')%                   U.mean	:   if Rall is available then%                                    U.mean is the mean value of the projected output Uall./Rall%                                    over all periods and realisations%                               else%                                   U.mean is empty except if M = 1 then U.mean is the mean value of the%                                   output over all periods%                   U.abs	:   if Rall is available then%                                   U.abs = abs(U.mean) %                               else%                                   rms value |U(k)| over different realisations compensated for the noise variance %                   U.stdNL :   total variance U.mean (as complex number) %                   U.stdn  :   noise variance U.mean (as complex number)%                   U.stds  :   input stochastic nonlinear distortions w.r.t. one multisine realisation %%       CYU     :   struct('NL', 'n')%                   CYU.NL  :   total covariance matrix of [Y; U], size 2 x 2 x F (noise + NL distortion)%                                   CYU.NL(1, 1) = varY = E{|NY|^2}/(M*P) + E{|YS|^2}/M %                                   CYU.NL(2, 2) = varU = E{|NU|^2}/(M*P) + E{|US|^2}/M %                                   CYU.NL(1, 2) = varYU = E{NY * conj(NU)}/(M*P) %                                   CYU.NL(2, 1) = varUY = E{NU * conj(NY)}/(M*P) + E{YS * conj(US)}/M %                               with NX the noise on X w.r.t one period, and YS the stochastic NL distortions w.r.t. one experiment %                               Notes: %                                       - calculated only if Yall, Uall, and Rall are available %                                       - if the actuator is linear then US = 0 (no nonlinear interaction%                                         between the generator and the NL system) %%                   CYU.n   :   noise covariance matrix of [Y.mean; U.mean] as complex numbers, size 2 x 2 x F%                                   CYU.n(1, 1) = varY = E{|NY|^2}/(M*P)%                                   CYU.n(2, 2) = varU = E{|NU|^2}/(M*P)%                                   CYU.n(1, 2) = varYU = E{NY * conj(NU)}/(M*P)%                                   CYU.n(2, 1) = varUY = E{NU * conj(NY)}/(M*P) %                               with NX the noise on X w.r.t. one period%%	INPUT PARAMETERS%%	    Yall	:	M x P x F FRF or output spectrum measurements, where F is the number of frequencies,%				    P the number of consecutive periods of one realisation of the random multisine excitation,%                   and M is the number of independent realisations of the random phase multisine with%                       1. the same rms value%                       2. the same amplitude spectrum%                   If only one argument is passed then Yall = Gall = FRF measurements%       Uall    :   Optional argument, M x P x F input spectrum measurements%       Rall    :   Optional argument, M x P x F or M x F matrix of the spectra of the M reference signals (signal stored in the waveform generator)%% Rik Pintelon, November 2004% version December 2007%%%%%%%%%%%%%%%%%%%% initialisation %%%%%%%%%%%%%%%%%%%[M, P, F] = size(Yall);G = struct('mean', [], 'stdn', [], 'stdNL', [], 'stds', []);Y = struct('mean', [], 'abs', [], 'stdn', [], 'stdNL', [], 'stds', []);U = struct('mean', [], 'abs', [], 'stdn', [], 'stdNL', [], 'stds', []);CYU = struct('NL', [], 'n', []);%%%%%%%%%%%%%%%%%%%%%%%%%% FRF measurements only %%%%%%%%%%%%%%%%%%%%%%%%%%if (nargin == 1)    	G.mean = squeeze(mean(mean(Yall, 2), 1));	if M > 1		G.stdNL = squeeze(std(mean(Yall, 2), 0, 1))/sqrt(M);	end;	if P > 1		G.stdn = (squeeze(mean(std(Yall, 0, 2).^2, 1))/(M*P)).^0.5;	end    end % if nargin = 1%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% input/output measurements %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if (nargin == 2) | (nargin == 3)        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % If the reference signal is available then project      %    % input and output on reference signal.                  %    % It allows to average the spectra over the realisations %    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    if nargin == 3               % calculating exp(j*angle(R))        Rall = Rall ./ abs(Rall);               % M x F matrix of reference spectra        if length(size(Rall)) == 2            dummy = zeros(M, 1, F);            dummy(:, 1, :) = Rall;            Rall = repmat(dummy, [1, P, 1]);        end % if dim(Rall) = 2                % turn input/output spectra with the phase of the reference signal        Uall = Uall ./ Rall;        Yall = Yall ./ Rall;            end % if nargin = 3        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % mean and variance over P periods %    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % averaging spectra over periods before FRF calculation    Uallm = mean(Uall, 2);                                              % mean over consecutive periods	Yallm = mean(Yall, 2);                                              % mean over consecutive periods    if P > 1		resUall = Uall - repmat(Uallm, [1, P, 1]);		resYall = Yall - repmat(Yallm, [1, P, 1]);		varUallm = squeeze((sum(abs(resUall.^2), 2)/(P-1)/P));          % var mean value over P periods		varYallm = squeeze((sum(abs(resYall.^2), 2)/(P-1)/P));          % var mean value over P periods		varYUallm = squeeze(sum(resYall.*conj(resUall), 2)/(P-1)/P);    % covariance mean values over P periods    end % if P > 1	Uallm = squeeze(Uallm);	Yallm = squeeze(Yallm);	if M == 1        Uallm = Uallm.';        Yallm = Yallm.';        U.mean = Uallm;        Y.mean = Yallm;        if P > 1             varUallm = varUallm.';            varYallm = varYallm.';            varYUallm = varYUallm.';        end % if P > 1	end % if M == 1    if P > 1                % input/output noise (co-)variances        varUn = mean(varUallm, 1)/M;        varYn = mean(varYallm, 1)/M;        varYUn = mean(varYUallm, 1)/M;                % noise covariance matrix [Y; U]        CYU.n = zeros(2, 2, F);        CYU.n(1, 1, :) = varYn;        CYU.n(2, 2, :) = varUn;        CYU.n(1, 2, :) = varYUn;        CYU.n(2, 1, :) = conj(varYUn);        Y.stdn = varYn.^0.5;        U.stdn = varUn.^0.5;               end % if P > 1        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % Mean and variance over M realisations in the absence of a reference signal          %    % Averaging spectra over realisations is impossible because they are not synchronized %    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        if nargin == 2                Gallm = Yallm./Uallm;        G.mean = mean(Gallm, 1);                % removal noise bias in (cross-)power spectra        absY2 = mean(abs(Yallm.^2), 1) - M*varYn;        absU2 = mean(abs(Uallm.^2), 1) - M*varUn;        YconjU = mean(Yallm .* conj(Uallm), 1) - M*varYUn;        Y.abs = absY2.^0.5;        U.abs = absU2.^0.5;                % noise std mean FRF        G.stdn = abs(G.mean) .* (varYn./absY2 + varUn./absU2 - 2*real(varYUn./YconjU)).^0.5;		if M > 1			G.stdNL = std(Gallm, 0, 1) / sqrt(M);       % standard deviation mean value            Y.stdNL = G.stdNL .* U.abs;                 % standard deviation mean value		end;            end % if nargin = 2                             %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % Mean and variance over M realisations in the presence of a reference signal %    % Due to the projection on the reference signal averaging of the spectra over %    % different realisations is possible                                          %    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        if nargin == 3                % mean value over realisations        Y.mean = mean(Yallm, 1);        U.mean = mean(Uallm, 1);        Y.abs = abs(Y.mean);        U.abs = abs(U.mean);        G.mean = Y.mean./U.mean;                        % noise variance mean FRF        G.stdn = abs(G.mean) .* (varYn./abs(Y.mean.^2) + varUn./abs(U.mean.^2) ...                                            - 2*real(varYUn./(Y.mean.*conj(U.mean)))).^0.5;                   if M > 1			resU = Uallm - repmat(U.mean, [M, 1]);			resY = Yallm - repmat(Y.mean, [M, 1]);			varU = (sum(abs(resU.^2), 1)/(M-1)/M);                  % var mean value over M realisations			varY = (sum(abs(resY.^2), 1)/(M-1)/M);                  % var mean value over M realisations			varYU = sum(resY.*conj(resU), 1)/(M-1)/M;               % covariance mean values over M realisations                        % total covariance matrix [Y; U]            CYU.NL = zeros(2, 2, F);            CYU.NL(1, 1, :) = varY;            CYU.NL(2, 2, :) = varU;            CYU.NL(1, 2, :) = varYU;            CYU.NL(2, 1, :) = conj(varYU);            Y.stdNL = varY.^0.5;            U.stdNL = varU.^0.5;                        % total std mean FRF            G.stdNL = abs(G.mean) .* (varY./abs(Y.mean.^2) + varU./abs(U.mean.^2) ...                                                - 2*real(varYU./(Y.mean.*conj(U.mean)))).^0.5;        end % if M > 1                    end % if nargin = 3    end % if nargin = 2 or nargin = 3%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% standard deviation stochastic nonlinear distortions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if (M > 1) & (P > 1)        % estimate GS    G.stds = (M * abs(G.stdNL.^2 - G.stdn.^2)).^0.5;        % estimate YS    if nargin > 1   % input/output measurements        Y.stds = (M * abs(Y.stdNL.^2 - Y.stdn.^2)).^0.5;    end % if nargin > 1        % estimate US    if nargin == 3  % reference signal is available        U.stds = (M * abs(U.stdNL.^2 - U.stdn.^2)).^0.5;    end % if nargin > 1    endfunction [G, varG, freq, Cov_vecG] = BLA_arb(y, u, N, fs)%%   function [G, varG, freq, Cov_vecG] = BLA_arb(y, u, N, fs);%%       calculation best linear approximation via %       division cross-power spectrum by auto-power spectrum%%   Output%       G           =   estimated frequency response function (FRF)%       varG        =   variance estimated FRF%       freq        =   frequencies at which FRF is estimated%       Cov_vecG	=   covariance matrix of vec(G) (for MIMO systems only)%%   Input%       y           =   output signal; size N*M x 1 or 1x N*M or ny x N*M%       u           =   input signal; size N*M x 1 or 1 x N*M or nu x N*M%       N           =   block length for FRF estimate%       fs          =   sampling frequency%%   Rik Pintelon and Johan Schoukens%   March 23, 2007%   version 18 June 2010%% number of inputs and outputsny = min(size(y));nu = min(size(u));% number of blocksM = floor(length(u)/N);% frequencies at which the FRF is calculatedfreq = ([1:1:N/2-2].' + 0.5)*fs/N;if ny*nu == 1        %%%%%%%%    % SISO %    %%%%%%%%        u = u(:);    y = y(:);    u = reshape(u(1:M*N), N, M);    y = reshape(y(1:M*N), N, M);    u = fft(u, [], 1)/sqrt(N);    u = u(2:N/2, :);    y = fft(y, [], 1)/sqrt(N);    y = y(2:N/2, :);    % leakage suppression by taking the difference    u = diff(u, 1, 1);    y = diff(y, 1, 1);    % FRF estimate Syu/Suu    Syu = mean(y.*conj(u), 2);    Suu = mean(abs(u.^2), 2);    G = Syu ./ Suu;    % variance estimate FRF    Syy = mean(abs(y.^2), 2);    varG = 1/(M-1) * (Syy - abs(Syu.^2)./Suu)./Suu;    else        %%%%%%%%    % MIMO %    %%%%%%%%        % put the vectors in the correct format    if ny == 1        y = y(:).';    end % if ny = 1    if nu == 1        u = u(:).';    end % if nu = 1       % take fft of each segment    y = y(:,1:M*N);    u = u(:,1:M*N);    y = reshape(y, [ny, N, M]);    u = reshape(u, [nu, N, M]);    y = permute(y, [1, 3, 2]);    u = permute(u, [1, 3, 2]);    Y = fft(y, [], 3)/sqrt(N);		% ny x M x N matrix    U = fft(u, [], 3)/sqrt(N);    Y = Y(:,:,2:N/2);    U = U(:,:,2:N/2);    % differentiate to suppress leakage    Y = diff(Y, 1, 3);    U = diff(U, 1, 3);    F = size(Y, 3);    % estimate output power spectrum = sum true output power + noise power    Syy = zeros(ny, ny, F);    for ii = 1:ny        for jj = 1:ii            Syy(ii, jj, :) = mean(Y(ii, :, :).*conj(Y(jj, :, :)), 2);            Syy(jj, ii, :) = conj(Syy(ii, jj, :));        end % jj    end % ii    % estimate input power spectrum    Suu = zeros(nu, nu, F);    for ii = 1:nu        for jj = 1:ii            Suu(ii, jj, :) = mean(U(ii, :, :).*conj(U(jj, :, :)), 2);            Suu(jj, ii, :) = conj(Suu(ii, jj, :));        end % jj    end % ii    % estimate cross power spectrum    Syu = zeros(ny, nu, F);    for ii = 1:ny        for jj = 1:nu            Syu(ii, jj, :) = mean(Y(ii, :, :).*conj(U(jj, :, :)), 2);        end % jj    end % ii    % estimate output noise power spectrum and FRF    Cy = zeros(ny, ny, F);    G = zeros(ny, nu, F);    Cov_vecG = zeros(ny*nu, ny*nu, N-1);    for kk = 1:F        invSuu = inv(squeeze(Suu(:, :, kk)));        G(:, :, kk) = Syu(:, :, kk)*invSuu;        Cy(:, :, kk) = Syy(:, :, kk) - G(:, :, kk)*Syu(:, :, kk)';        % remove imaginary part on diagonal        Cy(:, :, kk) = Cy(:, :, kk) - diag(sqrt(-1)*imag(diag(Cy(:, :, kk))));        % cov(vec(G)) = kron(inv(Suu).', Cy) / M        Cov_vecG(:, :, kk) = kron(invSuu.', squeeze(Cy(:, :, kk)));    end % kk    % correct for bias;not for diff because Suu and Cy are both 2 times    % too large => factor two cancels in the ratio:     %       kron(invSuu.', squeeze(Cy(:, :, kk)))    Cov_vecG = Cov_vecG/(M-nu);        % variance entries FRF    varG = zeros(ny, nu, F);    for kk = 1:F        varG(:, :, kk) = reshape(diag(squeeze(Cov_vecG(:, :, kk))), [ny, nu] );    end % kkend % if